import asyncio
import json
from typing import List
import signal
import sys

import uvicorn
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import ValidationError

import logging
from backend.services.storage import DatabaseManager
from backend.services.ws import ConnectionManager
from backend.services.proxy import ProxyManager
from backend.models.base_models import FilterModel, OperationType, RuleModel

from backend.models.flat_utils import create_server_started_message, create_server_stopped_message

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global instances
app = FastAPI(
    title="HTTP Flow API", 
    version="1.0.0",
    description="A powerful HTTP traffic interceptor and modifier with real-time rule-based request/response manipulation"
)
db = DatabaseManager()
connection_manager = ConnectionManager(logger)
proxy_manager = ProxyManager(connection_manager, proxy_port=8080)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify actual origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Graceful shutdown handler
def signal_handler(signum, frame):
    logger.info("Received shutdown signal, cleaning up...")
    asyncio.create_task(cleanup_on_exit())
    sys.exit(0)

async def cleanup_on_exit():
    """Clean up resources on server exit"""
    try:
        await proxy_manager.stop_proxy()
        logger.info("Cleanup completed")
    except Exception as e:
        logger.error(f"Error during cleanup: {e}")

# Register signal handlers
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

# REST API Endpoints

@app.get("/api/filters", response_model=List[FilterModel])
async def get_filters():
    """Get all filters"""
    return db.get_filters()

@app.post("/api/filters", response_model=FilterModel)
async def create_filter(filter_data: FilterModel):
    """Create a new filter"""
    try:
        result = db.create_filter(filter_data)
        proxy_manager.sync_filter(result, OperationType.ADD)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=f"Validation error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@app.put("/api/filters/{filter_id}", response_model=FilterModel)
async def update_filter(filter_id: int, filter_data: FilterModel):
    """Update an existing filter"""
    try:
        # Override model ID with URL ID to ensure consistency
        filter_data.id = filter_id
        result = db.update_filter(filter_id, filter_data)
        proxy_manager.sync_filter(result, OperationType.UPDATE)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=f"Validation error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@app.delete("/api/filters/{filter_id}")
async def delete_filter(filter_id: int):
    """Delete a filter"""
    existing_filter = db.get_filter_by_id(filter_id)
    if not existing_filter:
        raise HTTPException(status_code=404, detail="Filter not found")
    
    if db.delete_filter(filter_id):
        proxy_manager.sync_filter(existing_filter, OperationType.DELETE)
        return {"message": f"Filter {filter_id} deleted successfully"}
    raise HTTPException(status_code=404, detail="Filter not found")

@app.get("/api/rules", response_model=List[RuleModel])
async def get_rules():
    """Get all rules"""
    return db.get_rules()

@app.post("/api/rules", response_model=RuleModel)
async def create_rule(rule_data: RuleModel):
    """Create a new rule"""
    try:
        # Ensure ID is None for creation (will be generated by DB)
        rule_data.id = None
        result = db.create_rule(rule_data)
        proxy_manager.sync_rule(result, OperationType.ADD)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=f"Validation error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@app.put("/api/rules/{rule_id}", response_model=RuleModel)
async def update_rule(rule_id: int, rule_data: RuleModel):
    """Update an existing rule"""
    try:
        
        result = db.update_rule(rule_id, rule_data)
        proxy_manager.sync_rule(result, OperationType.UPDATE)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=f"Validation error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@app.delete("/api/rules/{rule_id}")
async def delete_rule(rule_id: int):
    """Delete a rule"""
    # Get the rule first for sync operation
    existing_rule = db.get_rule_by_id(rule_id)
    if not existing_rule:
        raise HTTPException(status_code=404, detail="Rule not found")
    
    if db.delete_rule(rule_id):
        proxy_manager.sync_rule(existing_rule, OperationType.DELETE)
        return {"message": "Rule deleted successfully"}
    raise HTTPException(status_code=404, detail="Rule not found")

@app.post("/api/interception/start")
async def start_interception():
    """Start HTTP interception"""
    try:
        success = await proxy_manager.start_proxy()
        if success:
            all_filters = db.get_filters()
            all_rules = db.get_rules()
            
            proxy_manager.full_sync(all_filters, all_rules)
            logger.info(f"Initial sync applied: {len(all_rules)} rules, {len(all_filters)} filters")
            
            start_event = create_server_started_message(proxy_manager.proxy_port)
            await connection_manager.broadcast(start_event)
            return {"status": "started", "proxy_port": proxy_manager.proxy_port}
        else:
            raise HTTPException(status_code=500, detail="Failed to start proxy server")
    except Exception as e:
        logger.error(f"Failed to start interception: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to start interception: {str(e)}")

@app.post("/api/interception/stop")
async def stop_interception():
    """Stop HTTP interception"""
    try:
        success = await proxy_manager.stop_proxy()
        if success:
            # Broadcast status change
            server_event = create_server_stopped_message(proxy_manager.proxy_port)
            await connection_manager.broadcast(server_event)
            return {"status": "stopped", "proxy_port": proxy_manager.proxy_port}
        else:
            logger.warning("Proxy stop returned false, but continuing...")
            return {"status": "stopped"}
    except Exception as e:
        logger.error(f"Failed to stop interception: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to stop interception: {str(e)}")

@app.get("/api/interception/status")
async def get_interception_status():
    """Get current interception status"""
    status = proxy_manager.get_status()
    return status

# WebSocket endpoint
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await connection_manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            # Handle WebSocket messages if needed
            message = json.loads(data)
            
            if message.get('type') == 'ping':
                await connection_manager.pong(websocket)
    except WebSocketDisconnect:
        connection_manager.disconnect(websocket)

# Startup and shutdown events
@app.on_event("startup")
async def startup_event():
    logger.info("HTTP Flow API starting up...")

@app.on_event("shutdown")
async def shutdown_event():
    logger.info("HTTP Flow API shutting down...")
    await cleanup_on_exit()

def main():
    """Main entry point for the application"""
    try:
        uvicorn.run(
            "backend.main:app",
            host="0.0.0.0",
            port=8000,
            reload=False,  # Disable reload to avoid issues with signal handlers
            log_level=None
        )
    except KeyboardInterrupt:
        logger.info("Server interrupted by user")
    finally:
        asyncio.run(cleanup_on_exit())

if __name__ == "__main__":
    main()
