// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { HeaderPair, HeaderPairT } from '../http-interceptor/header-pair.js';


export class FlowData implements flatbuffers.IUnpackableObject<FlowDataT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):FlowData {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsFlowData(bb:flatbuffers.ByteBuffer, obj?:FlowData):FlowData {
  return (obj || new FlowData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsFlowData(bb:flatbuffers.ByteBuffer, obj?:FlowData):FlowData {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new FlowData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

method():string|null
method(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
method(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

url():string|null
url(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
url(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

status():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

startTimestamp():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

endTimestamp():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

requestSize():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

responseSize():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

requestHeaders(index: number, obj?:HeaderPair):HeaderPair|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? (obj || new HeaderPair()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

requestHeadersLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

responseHeaders(index: number, obj?:HeaderPair):HeaderPair|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? (obj || new HeaderPair()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

responseHeadersLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

requestBody():string|null
requestBody(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
requestBody(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

responseBody():string|null
responseBody(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
responseBody(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

isIntercepted():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startFlowData(builder:flatbuffers.Builder) {
  builder.startObject(13);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addMethod(builder:flatbuffers.Builder, methodOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, methodOffset, 0);
}

static addUrl(builder:flatbuffers.Builder, urlOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, urlOffset, 0);
}

static addStatus(builder:flatbuffers.Builder, status:number) {
  builder.addFieldInt16(3, status, 0);
}

static addStartTimestamp(builder:flatbuffers.Builder, startTimestamp:number) {
  builder.addFieldFloat64(4, startTimestamp, 0.0);
}

static addEndTimestamp(builder:flatbuffers.Builder, endTimestamp:number) {
  builder.addFieldFloat64(5, endTimestamp, 0.0);
}

static addRequestSize(builder:flatbuffers.Builder, requestSize:number) {
  builder.addFieldInt32(6, requestSize, 0);
}

static addResponseSize(builder:flatbuffers.Builder, responseSize:number) {
  builder.addFieldInt32(7, responseSize, 0);
}

static addRequestHeaders(builder:flatbuffers.Builder, requestHeadersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, requestHeadersOffset, 0);
}

static createRequestHeadersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startRequestHeadersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addResponseHeaders(builder:flatbuffers.Builder, responseHeadersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, responseHeadersOffset, 0);
}

static createResponseHeadersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startResponseHeadersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addRequestBody(builder:flatbuffers.Builder, requestBodyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, requestBodyOffset, 0);
}

static addResponseBody(builder:flatbuffers.Builder, responseBodyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, responseBodyOffset, 0);
}

static addIsIntercepted(builder:flatbuffers.Builder, isIntercepted:boolean) {
  builder.addFieldInt8(12, +isIntercepted, +false);
}

static endFlowData(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // id
  builder.requiredField(offset, 6) // method
  builder.requiredField(offset, 8) // url
  builder.requiredField(offset, 20) // request_headers
  builder.requiredField(offset, 22) // response_headers
  builder.requiredField(offset, 24) // request_body
  builder.requiredField(offset, 26) // response_body
  return offset;
}

static createFlowData(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, methodOffset:flatbuffers.Offset, urlOffset:flatbuffers.Offset, status:number, startTimestamp:number, endTimestamp:number, requestSize:number, responseSize:number, requestHeadersOffset:flatbuffers.Offset, responseHeadersOffset:flatbuffers.Offset, requestBodyOffset:flatbuffers.Offset, responseBodyOffset:flatbuffers.Offset, isIntercepted:boolean):flatbuffers.Offset {
  FlowData.startFlowData(builder);
  FlowData.addId(builder, idOffset);
  FlowData.addMethod(builder, methodOffset);
  FlowData.addUrl(builder, urlOffset);
  FlowData.addStatus(builder, status);
  FlowData.addStartTimestamp(builder, startTimestamp);
  FlowData.addEndTimestamp(builder, endTimestamp);
  FlowData.addRequestSize(builder, requestSize);
  FlowData.addResponseSize(builder, responseSize);
  FlowData.addRequestHeaders(builder, requestHeadersOffset);
  FlowData.addResponseHeaders(builder, responseHeadersOffset);
  FlowData.addRequestBody(builder, requestBodyOffset);
  FlowData.addResponseBody(builder, responseBodyOffset);
  FlowData.addIsIntercepted(builder, isIntercepted);
  return FlowData.endFlowData(builder);
}

unpack(): FlowDataT {
  return new FlowDataT(
    this.id(),
    this.method(),
    this.url(),
    this.status(),
    this.startTimestamp(),
    this.endTimestamp(),
    this.requestSize(),
    this.responseSize(),
    this.bb!.createObjList<HeaderPair, HeaderPairT>(this.requestHeaders.bind(this), this.requestHeadersLength()),
    this.bb!.createObjList<HeaderPair, HeaderPairT>(this.responseHeaders.bind(this), this.responseHeadersLength()),
    this.requestBody(),
    this.responseBody(),
    this.isIntercepted()
  );
}


unpackTo(_o: FlowDataT): void {
  _o.id = this.id();
  _o.method = this.method();
  _o.url = this.url();
  _o.status = this.status();
  _o.startTimestamp = this.startTimestamp();
  _o.endTimestamp = this.endTimestamp();
  _o.requestSize = this.requestSize();
  _o.responseSize = this.responseSize();
  _o.requestHeaders = this.bb!.createObjList<HeaderPair, HeaderPairT>(this.requestHeaders.bind(this), this.requestHeadersLength());
  _o.responseHeaders = this.bb!.createObjList<HeaderPair, HeaderPairT>(this.responseHeaders.bind(this), this.responseHeadersLength());
  _o.requestBody = this.requestBody();
  _o.responseBody = this.responseBody();
  _o.isIntercepted = this.isIntercepted();
}
}

export class FlowDataT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public method: string|Uint8Array|null = null,
  public url: string|Uint8Array|null = null,
  public status: number = 0,
  public startTimestamp: number = 0.0,
  public endTimestamp: number = 0.0,
  public requestSize: number = 0,
  public responseSize: number = 0,
  public requestHeaders: (HeaderPairT)[] = [],
  public responseHeaders: (HeaderPairT)[] = [],
  public requestBody: string|Uint8Array|null = null,
  public responseBody: string|Uint8Array|null = null,
  public isIntercepted: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const method = (this.method !== null ? builder.createString(this.method!) : 0);
  const url = (this.url !== null ? builder.createString(this.url!) : 0);
  const requestHeaders = FlowData.createRequestHeadersVector(builder, builder.createObjectOffsetList(this.requestHeaders));
  const responseHeaders = FlowData.createResponseHeadersVector(builder, builder.createObjectOffsetList(this.responseHeaders));
  const requestBody = (this.requestBody !== null ? builder.createString(this.requestBody!) : 0);
  const responseBody = (this.responseBody !== null ? builder.createString(this.responseBody!) : 0);

  return FlowData.createFlowData(builder,
    id,
    method,
    url,
    this.status,
    this.startTimestamp,
    this.endTimestamp,
    this.requestSize,
    this.responseSize,
    requestHeaders,
    responseHeaders,
    requestBody,
    responseBody,
    this.isIntercepted
  );
}
}
